# Архитектура Игры: Логика, Данные и Ходы

## 1. Логика Игры (Гибридный Подход)

Логика игры распределена между клиентом и сервером для обеспечения отзывчивости интерфейса и надежности данных.

### Клиентская сторона (`frontend/src/pages/Game.jsx`)
*   **Библиотека**: Используется `chess.js` для управления состоянием доски и валидации ходов в браузере.
*   **Исполнение**:
    *   Пользователь делает ход.
    *   Клиент проверяет легальность хода локально.
    *   Применяется "оптимистичное обновление" (Optimistic UI): доска обновляется мгновенно, не дожидаясь ответа от сервера.
    *   Если сервер отклоняет ход, состояние откатывается назад.

### Серверная сторона (`backend/games.py`)
*   **Библиотека**: Также используется Python-версия `chess` (python-chess).
*   **Роль**: Является единственным источником истины (Source of Truth).
*   **Валидация**:
    *   Проверяет очередность хода.
    *   Проверяет принадлежность игрока к текущей партии.
    *   Проверяет легальность хода по правилам шахмат.
    *   Фиксирует окончание игры (мат, пат, сдача).

## 2. Поток Данных (Архитектура HTTP + WebSocket)

Используется комбинированный подход для передачи данных.

### Отправка Хода
1.  **Действие**: Игрок совершает ход на доске.
2.  **Запрос**: Клиент отправляет HTTP `POST` запрос на `/games/{id}/move`.
    *   Тело запроса: `{ "san": "e4" }` (Standard Algebraic Notation).
3.  **Обработка**: Сервер валидирует ход, обновляет базу данных и возвращает подтверждение.

### Получение Обновлений (Real-time)
1.  **Соединение**: При входе в игру клиент устанавливает WebSocket-соединение с `/ws/game/{id}`.
2.  **Бродкаст**: После успешного обновления состояния игры (успешный `POST` запрос), сервер рассылает всем подписчикам этого `game_id` сообщение:
    *   `"move:<move_san>"` — если сделан ход.
    *   `"player_joined"` — если подключился второй игрок.
3.  **Синхронизация**: При получении сообщения по WebSocket, клиент инициирует HTTP `GET` запрос к `/games/{id}` для получения полного актуального состояния игры. Это защищает от рассинхронизации.

## 3. Хранение Данных (PostgreSQL)

История и состояние хранятся в реляционной базе данных.

### Таблица `games`
Хранит текущий "снимок" игры.
*   `id`: Уникальный идентификатор игры.
*   `fen`: Текущая позиция в формате FEN (Forsyth–Edwards Notation).
*   `status`: Состояние игры (`waiting`, `active`, `finished`).
*   `white_player_id` / `black_player_id`: Ссылки на пользователей.

### Таблица `moves`
Хранит полный лог ходов для восстановления истории.
*   `game_id`: Ссылка на игру.
*   `move_san`: Текстовая запись хода (например, "Nf3").
*   `fen_after`: Состояние доски (FEN) *после* этого хода. Используется для быстрой навигации и восстановления.
*   `created_at`: Таймштамп для сортировки порядка ходов.

### Восстановление Игры
При загрузке страницы (`read_game`):
1.  Загружается объект `Game`.
2.  Загружаются все связанные `Move` записи.
3.  На клиенте создается новый экземпляр `Chess()`.
4.  Клиент последовательно применяет все ходы из истории, чтобы прийти к текущей позиции и отобразить историю ходов справа от доски.
